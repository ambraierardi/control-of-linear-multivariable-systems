%% Control Allocation



%code those three eq, choose whatever input 
%we must stay around the state, can't start far from the state, otherwise
%chanses to converge are very very low
clc
clear
close all

% initialization
T_thruster = [0.7071, 0.7071, -0.7071, -0.7071;
              -0.7071, 0.7071, -0.7071, 0.7071;
              -0.1888, 0.1888, 0.1888, -0.1888];

[n,m] = size(T_thruster);
%m number of thrusters
%n number of equations

r = rank(T_thruster); 

 K = 30* eye(4); % the thrust coefficient
Volt = zeros(m,1); % the applied volt for the thrusters
F = zeros(n,1); % the forces and a moment generated by the thrusters


%% Weighted least square solution
% general case y = M * x
% ROV case   F = T*K*Volt

 M = T_thruster*K;

Q = eye(4);% weight matrix

%Mr = inv(Q) * transpose(M) *inv( M *inv(Q) * transpose(M));
Mr = (Q) * transpose(M) /inv( M *(Q) * transpose(M)); % wieghted right pseudo-inverse of M

P = eye(4) - Mr*M; %Projector in the Kernel

% set desired force
F = [1.0, 0.0, 0.0]';


% compute input voltage
Volt = Mr * F ;
% check if M*volt = F
M * Volt == F
%viene comunque, solo problema approx
%% SVD
% Divide M to UDV matrices
[U,D,V] = svd(M);% run SVD function

% check if M = U*D*V'
trial=round(U*D*transpose(V),5);
trial == M
%viene, solo problema approx

% compute D#
D_dash = [1/D(1,1), 0 , 0 ; 0, 1/D(2,2), 0; 0, 0, 1/D(3,3); 0, 0, 0];

M_inv = V*D_dash*transpose(U);% right pseudo-inverse of M

P_svd = eye(4) - M_inv*M; %Projector in the Kernel

% compute input voltage
Volt_svd = M_inv * F;

% check if M*volt = F
prova=(M* Volt_svd);
prova==F